/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package edu.msu.cme.rdp.kmer.trie;

import edu.msu.cme.rdp.readseq.SequenceType;
import edu.msu.cme.rdp.readseq.readers.SeqReader;
import edu.msu.cme.rdp.readseq.readers.Sequence;
import edu.msu.cme.rdp.readseq.utils.SeqUtils;
import edu.msu.cme.rdp.readseq.utils.IUBUtilities;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Serializable;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

/**
 *
 * @author fishjord
 */
public class KmerTrie implements Serializable {

    private static final byte[] alphaMap = new byte[127];
    private static final int rnaAlphaSize = 4;
    private static final int proteinAlphaSize;

    static {
        Arrays.fill(alphaMap, (byte) -1);
        alphaMap['a'] = alphaMap['A'] = 0;
        alphaMap['c'] = alphaMap['C'] = 1;
        alphaMap['g'] = alphaMap['G'] = 2;
        alphaMap['t'] = alphaMap['T'] = alphaMap['u'] = alphaMap['U'] = 3;

        byte nextIndex = 4;
        for (Character c : SeqUtils.proteinAlphabet) {
            c = Character.toLowerCase(c);
            if (alphaMap[c] == -1) {
                alphaMap[c] = alphaMap[Character.toUpperCase(c)] = nextIndex++;
            }
        }

        proteinAlphaSize = nextIndex;
    }

    private abstract static class TrieNode {
    }

    private static class TrieInteriorNode extends TrieNode {

        TrieNode[] children;
    }

    public static class TrieLeaf extends TrieNode {

        private int frame = 0;
        private int count = 0;
        private int queryCount = 0;
        private int modelPos;

        public TrieLeaf(int frame, int modelPos) {
            this.frame = frame;
            this.modelPos = modelPos;
        }

        public int getFrame() {
            return frame;
        }

        public int getCount() {
            return count;
        }

        public int getModelPos() {
            return modelPos;
        }

        public synchronized void incQueryCount() {
            queryCount++;
        }

        public int getQueryCount() {
            return queryCount;
        }

        void inc() {
            count++;
        }
    }
    private final TrieNode root;
    private final boolean isProtein;
    private final int k;
    private int seqCount;

    public KmerTrie(int k, boolean isProtein) {
        this.k = k;
        this.isProtein = isProtein;

        TrieInteriorNode rootNode = new TrieInteriorNode();
        rootNode.children = new TrieNode[isProtein ? proteinAlphaSize : rnaAlphaSize];
        root = rootNode;
    }

    public int getWordSize() {
        return k;
    }

    public static KmerTrie buildTrie(SeqReader reader, int k) throws IOException {
        Sequence seq = reader.readNextSequence();

        if (seq == null) {
            throw new IOException("Sequence file contains no sequences");
        }
        KmerTrie trie = new KmerTrie(k, SeqUtils.guessSequenceType(seq) == SequenceType.Protein);

        do {
            trie.addSequence(seq);
        } while ((seq = reader.readNextSequence()) != null);

        return trie;
    }

    public static KmerTrie buildTrieFromAligned(SeqReader reader, final int k) throws IOException {
        Sequence seq = reader.readNextSequence();

        if (seq == null) {
            throw new IOException("Sequence file contains no sequences");
        }
        KmerTrie trie = new KmerTrie(k, SeqUtils.guessSequenceType(seq) == SequenceType.Protein);

        do {
            if (seq.getSeqName().startsWith("#")) {
                continue;
            }

            ModelPositionKmerGenerator kmers = new ModelPositionKmerGenerator(seq.getSeqString(), k);

            for (char[] kmer : kmers) {
                TrieLeaf leaf = trie.contains(kmer);
                if (leaf != null && leaf.getModelPos() != kmers.getModelPosition()) {
                    System.err.println("Kmer " + new String(kmer) + ", current seq is " + seq.getSeqName() + " appears in multiple model positions (" + (kmers.getModelPosition()) + ", " + leaf.modelPos + " count=" + leaf.getCount() + "), perhaps use a larger word size?");
                }
                trie.addKmer(kmer, -1, kmers.getModelPosition());

            }
            trie.seqCount++;
        } while ((seq = reader.readNextSequence()) != null);

        return trie;
    }

    private void addKmer(char[] kmer, int frame, int modelPos) {
        if (kmer.length != k) {
            throw new IllegalArgumentException(new String(kmer) + "'s length doesn't match expected (" + k + ")");
        }
        addKmer(kmer, 0, frame, modelPos);
    }

    private void addKmer(char[] kmer, int offset, int frame, int modelPos) {
        if (offset + k > kmer.length) {
            throw new IllegalArgumentException("Array offset doesn't leave enough room for a full kmer");
        }

	TrieNode curr = root;
	TrieInteriorNode node;
	int end = offset + k;
	    
	for (int index = offset; index < end; index++) {
	    char c = kmer[index];
	    node = (TrieInteriorNode) curr;

	    if (node.children[alphaMap[c]] == null) {
		if (index + 1 == end) {
		    curr = new TrieLeaf(frame, modelPos);
		    node.children[alphaMap[c]] = curr;
		} else {
		    TrieInteriorNode interNode = new TrieInteriorNode();
		    interNode.children = new TrieNode[isProtein ? proteinAlphaSize : rnaAlphaSize];
		    node.children[alphaMap[c]] = interNode;
		    
		    curr = interNode;
		}
	    } else {
		curr = node.children[alphaMap[c]];
	    }
	}
	
	((TrieLeaf) curr).inc();
    }

    public void addSequence(Sequence seq) {

        int frame = 0;
        char[] bases = seq.getSeqString().toCharArray();

        for (int index = 0; index <= bases.length - k; index++) {
            if (isProtein) {
                addKmer(bases, index, -1, -1);
            } else {
                addKmer(bases, index, frame, -1);
                frame = (frame > 1) ? 0 : frame++;
            }
        }
        seqCount++;
    }

    public TrieLeaf contains(char[] kmer) {
        if (kmer.length != k) {
            throw new IllegalArgumentException(new String(kmer) + "'s length doesn't match expected (" + k + ")");
        }

        return contains(kmer, 0);
    }

    private TrieLeaf contains(char[] kmer, int offset) {
	return containsInternal(kmer, offset);
    }

    private TrieLeaf containsInternal(char[] kmer, int offset) {
        if (offset + k > kmer.length) {
            throw new IllegalArgumentException("Array offset doesn't leave enough room for a full kmer " + offset + ", " + k + " " + kmer.length);
        }
        TrieNode curr = root;
        TrieInteriorNode node;

        for (int index = offset; index < offset + k; index++) {
            char c = kmer[index];
            node = (TrieInteriorNode) curr;

            if (node.children[alphaMap[c]] == null) {
                return null;
            }
            curr = node.children[alphaMap[c]];
        }

        return ((TrieLeaf) curr);
    }

    public SequenceType getTreeSeqType() {
        return isProtein ? SequenceType.Protein : SequenceType.Nucleotide;
    }

    public int getSeqCount() {
        return seqCount;
    }

    public int uniqueWords() {
        return countUniqueWords(root);
    }

    private int countUniqueWords(TrieNode node) {
        int ret = 0;

        if (node instanceof TrieLeaf) {
            return 1;
        } else {
            TrieInteriorNode curr = (TrieInteriorNode) node;
            TrieNode child = null;
            for (int index = 0; index < curr.children.length; index++) {
                child = curr.children[index];

                if (child != null) {
                    ret += countUniqueWords(child);
                }
            }
        }

        return ret;
    }

    public int countNodes() {
        return countNodes(root);
    }

    private int countNodes(TrieNode node) {
        int ret = 0;

        if (node instanceof TrieLeaf) {
            return 1;
        } else {
            TrieInteriorNode curr = (TrieInteriorNode) node;
            TrieNode child = null;
            for (int index = 0; index < curr.children.length; index++) {
                child = curr.children[index];

                if (child != null) {
                    ret += countNodes(child);
                }
            }
        }

        return ret + 1;
    }

    public void printWordHistogram(PrintWriter out) {
        printWordHistogram(root, new char[k], 0, out);
    }

    private int printWordHistogram(TrieNode node, char[] currWord, int depth, PrintWriter out) {
        int ret = 0;

        if (node instanceof TrieLeaf) {
            out.print(currWord);
            out.println("\t" + ((TrieLeaf) node).count);
        } else {
            TrieInteriorNode curr = (TrieInteriorNode) node;
            TrieNode child = null;
            for (int index = 0; index < curr.children.length; index++) {
                child = curr.children[index];

                if (child != null) {
                    char c = 'n';

                    for (int alphaIndex = 0; alphaIndex < proteinAlphaSize; alphaIndex++) {
                        if (alphaMap[alphaIndex] == index) {
                            c = (char) alphaIndex;
                        }
                    }

                    currWord[depth] = c;
                    printWordHistogram(child, currWord, depth + 1, out);
                }
            }
        }

        return ret + 1;
    }
}
